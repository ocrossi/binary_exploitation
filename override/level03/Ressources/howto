we have main, calls test function with a radom seed
then goes to test, calls a bunch of decrypt functions

decrypt call to bin/sh, our win cond, np idea whatsoever for tis lv


start with a srand(time(0))

approach to this was finding a good unix timestamp to match the cond
(0x1337d00d - rand()) = 18

for now the problem is there is to much values to test

next possibilities would be:
- multi thread
- MORE POWER + remove printf in loop to gain time

finally reading asm closer shows us sth that was confusing in ghidra
the switch case depends on multiple things:
- to begin with the cmp with 15 makes sure leetdood-input res is different than 15, else go to the random decrypt
- if it differs from 15, we have 3 "groups" ov value possible
	- leetdood-input res [1-9] : case 1 to 9
	- leetdood-input res [10-14] : rand
	- leetdood-input res [16-22] : case 10 to 16

the thing that really happens in asm is within those dirty lines
`
   0x08048766 <+31>:	mov    eax,DWORD PTR [ebp-0xc] 	# leetdood-input
   0x08048769 <+34>:	shl    eax,0x2			# leetdood-input * 4
   0x0804876c <+37>:	add    eax,0x80489f0		# add 0x80489f0 offset to res
   0x08048771 <+42>:	mov    eax,DWORD PTR [eax]	# put what is stored on stack at address eax in eax
   0x08048773 <+44>:	jmp    eax			# finally the jump
`

SO if we go print whats at offset in groups of 4 bytes we get

0x80489f4:	0x08048775	0x08048785	0x08048795	0x080487a5
0x8048a04:	0x080487b5	0x080487c5	0x080487d5	0x080487e2
0x8048a14:	0x080487ef	0x0804884a	0x0804884a	0x0804884a #case 1-9 stops at 0x080487ef, then start random decryt
0x8048a24:	0x0804884a	0x0804884a	0x0804884a	0x080487fc #random decrypt and then case 10-16
0x8048a34:	0x08048809	0x08048816-pass|0x08048823	0x08048830
0x8048a44:	0x0804883d	0x2a2a2a2a



Password:322424827 gets us to test+207
and works for decrypt, still some things to check

