#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
//
   // 0x0804844c <+8>:	sub    esp,0x90
   // 0x08048452 <+14>:	mov    DWORD PTR [esp+0x8c],0x0
   // 0x0804845d <+25>:	mov    eax,ds:0x80497f0
   // 0x08048462 <+30>:	mov    DWORD PTR [esp+0x8],eax
   // 0x08048466 <+34>:	mov    DWORD PTR [esp+0x4],0x64
   // 0x0804846e <+42>:	lea    eax,[esp+0x28]
   // 0x08048472 <+46>:	mov    DWORD PTR [esp],eax
   // 0x08048475 <+49>:	call   0x8048350 <fgets@plt>
   // 0x0804847a <+54>:	mov    DWORD PTR [esp+0x8c],0x0
   // 0x08048485 <+65>:	jmp    0x80484d3 <main+143>
   //

	char str[100];
	char eos; //eos position = *str + 100
	int len;
	char test;

	eos = '\0';
	fgets(str, 100, stdin);
	*str+101 = eos;

   //
   // 0x080484d3 <+143>:	mov    ebx,DWORD PTR [esp+0x8c]			0 dans ebx
   // 0x080484da <+150>:	lea    eax,[esp+0x28]				eax = string de fgets
   // 0x080484de <+154>:	mov    DWORD PTR [esp+0x1c],0xffffffff		max int sur ce qui est pointe par l adresse a esp+1c
   // 0x080484e6 <+162>:	mov    edx,eax					res fgets dans edx
   // 0x080484e8 <+164>:	mov    eax,0x0					eax a 0
   // 0x080484ed <+169>:	mov    ecx,DWORD PTR [esp+0x1c]			ecx a 0xffffffff
   // 0x080484f1 <+173>:	mov    edi,edx					edi = string fgets
   // 0x080484f3 <+175>:	repnz scas al,BYTE PTR es:[edi]			strcmp de max int tant que != 0, tant que chaine continue
   // 0x080484f5 <+177>:	mov    eax,ecx					eax = MAX_INT-len(input)
   // 0x080484f7 <+179>:	not    eax					eax = MAX_INT - eax
   // 0x080484f9 <+181>:	sub    eax,0x1					eax --
   // 0x080484fc <+184>:	cmp    ebx,eax					if eax != '\0' || eax != 0
   // 0x080484fe <+186>:	jb     0x8048487 <main+67>			go to main+67
   //
	while (1) {
		len = strlen(str);
		if (len == 0)
			break;
		//
		// 0x08048487 <+67>:	lea    eax,[esp+0x28]			eax = str
		// 0x0804848b <+71>:	add    eax,DWORD PTR [esp+0x8c]		eax+0
		// 0x08048492 <+78>:	movzx  eax,BYTE PTR [eax]		mov le byte de poids faible de eax et le reste set a 0 dans eax 
		// 0x08048495 <+81>:	cmp    al,0x40				compare byte de poids faible de eax a 64
		// 0x08048497 <+83>:	jle    0x80484cb <main+135>		si al < 0x40 on jump	
		//
		test = (char)str;
		// 0x08048499 <+85>:	lea    eax,[esp+0x28]
		// 0x0804849d <+89>:	add    eax,DWORD PTR [esp+0x8c]
		// 0x080484a4 <+96>:	movzx  eax,BYTE PTR [eax]
		// 0x080484a7 <+99>:	cmp    al,0x5a
		// 0x080484a9 <+101>:	jg     0x80484cb <main+135>
		
		if (test > 64 && test <= 90) {
		// 0x080484ab <+103>:	lea    eax,[esp+0x28]			eax = str	
		// 0x080484af <+107>:	add    eax,DWORD PTR [esp+0x8c]		eax + 0
		// 0x080484b6 <+114>:	movzx  eax,BYTE PTR [eax]		eax = char(eax)
		// 0x080484b9 <+117>:	mov    edx,eax				edx = eax
		// 0x080484bb <+119>:	xor    edx,0x20				alors ici j crois qu il met en minuscule les majs
		// 0x080484be <+122>:	lea    eax,[esp+0x28]
		// 0x080484c2 <+126>:	add    eax,DWORD PTR [esp+0x8c]
		// 0x080484c9 <+133>:	mov    BYTE PTR [eax],dl		et il push les lowercased letters dans la string
			*test -=	32; // le xor?
		}
		// 0x080484cb <+135>:	add    DWORD PTR [esp+0x8c],0x1
		str++;

	}

	printf(str);
	exit(0);
}
