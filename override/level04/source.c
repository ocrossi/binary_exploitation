#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <string.h>


int main(int argc, char *argv[])
{
	/*
	* 0xb0 bytes for current stackframe
	* */
	long res;
	pid_t id_porcess = fork();	// id_porcess at es+0xac on stack, will store PID of son if 
				// success
	int zer = 0;
	char str[32];
	memset(str, 0, 32); // on en est main+65 le if

	if (id_porcess == 0) { // we are in the child process
		prctl(1, 1);
		ptrace(0, 0, 0, 0);
		puts("Give me some shellcode, k");
		gets(str);
		return;
	}
	/*
		0x08048769 <+161>:	lea    eax,[esp+0x1c]
		0x0804876d <+165>:	mov    DWORD PTR [esp],eax
		0x08048770 <+168>:	call   0x80484f0 <wait@plt> waits for child to end
		0x08048775 <+173>:	mov    eax,DWORD PTR [esp+0x1c]
		0x08048779 <+177>:	mov    DWORD PTR [esp+0xa0],eax
		0x08048780 <+184>:	mov    eax,DWORD PTR [esp+0xa0]
		0x08048787 <+191>:	and    eax,0x7f
		0x0804878a <+194>:	test   eax,eax
	* */
	do {
		wait(&zer);
		if ((zer & 0x7f == 0) || ((zer | 0x7f + 1) >> 1) == 0)) {
			puts("child is exiting...");
			return;
		}
		res = ptrace(3, id_process, 0x2c, 0);

	}
	while (res != 0xb);
	puts("no exec() for you");
	kill(id_process, 9);
	return EXIT_SUCCESS;
}
