we can see with a info function on gdb some fork functions in c
which adds a layer of complexity to debug prgm with gdb
cant break in main after fork cause exec follows the child process
so we go and enter
`set follow-fork-mode child`

and we can break in main without problem
once code c is done, we have a unprotected gets call, only execed in child process
playing a bit with input
with string 
    - length 160, bug
    - length 156, we loop in 1st cond??
    - length under 156, code works properly

and prog asks us for some shell code. Now the difficulty would be to understand how
the stack is layed out in child compared to parent.
But the thing would just be go to child, find offset to rewrite eip, point to our gets
pointer, exec shellcode and win

en fait si on reecrit 0xfffffd70c on prend controle exec prog, car cette addr
sur la stack contient un pointeur vers 
(gdb) x/wx 0xfffffd70c
    0xffffd70c:	0xf7e45513

(gdb) x/i  0xf7e45513
   0xf7e45513 <__libc_start_main+243>:	mov    DWORD PTR [esp],eax

et si on soustrait la d ou part gets (fd670) a la case qu on veut reecrire, on tombe bien
sur 156

donc exploit = nop*(156 - len(shellcode)) + shellcode + 0xfffffd670

si on test dans gdb on segfault bient sur [156-160], le probleme est de recup l exec

en fait le probleme est que le ptrace check qu on fasse pas n imp avec l exec du fils

"Brievement, ptrace() permet d’acceder en lecture/ecriture a tout l’espace
d’adressage d’un processus, c’est a dire aussi bien les donnees (.text, .data,
etc.) que les structures de controle comme les registres du processeur"

https://airbus-seclab.github.io/ptrace/SSTIC2006-Article-Playing_with_ptrace_for_fun_and_profit-bareil.pdf

avec le tag PTRACE_PEEKUSER | 0x3 ptrace va pouvoir Lire un mot à l'adresse addr dans l'espace USER du fils, qui contient les registres et diverses informations sur le processus
en fait il protege le fils  dun signal de sigkill, ce qui nous empeche d executer un shellcode
avec un execve

on va donc test un ret2libc & on va aussi essayer de creer notre shellcode avec un chmod from scratch
https://beta.hackndo.com/retour-a-la-libc/
https://medium.com/mii-cybersec/build-your-own-linux-shellcode-ddfc323f717b
https://www.youtube.com/watch?v=aTLfr6Hewr4

string "//home//users//level05/.pass" ==> "37371607e2f25303c6566756c6f2f23727563757f2f256d6f686f2f2" en little endian


shellcode pour le path
finalement la string n est pas reverse vorrectement, on reverse d abord la string et apres on la convertit en hex:

python3 -c 'print("//home//users//level05/.pass"[::-1].encode("ascii").hex())' | fold -w8 pour couper en 8

737361702e2f35306c6576656c2f2f73726573752f2f656d6f682f2f
